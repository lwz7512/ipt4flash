/* AS3*Copyright 2008 noponies || Dale Sattler*/package noponies.scrollingpanel.ui{		import com.greensock.TweenLite;	import com.greensock.easing.Strong;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.*;	import flash.filters.BlurFilter;	import flash.geom.Rectangle;	import flash.utils.Timer;		import noponies.scrollingpanel.display.NpScrollingPanelItem;	import noponies.scrollingpanel.events.NpScrollingPanelEvent;
	/**	*	<p>The NpScrollingPanel Class is designed to create a scrolling pane of content. The Class itself does not handle any loading in of content. You must	*	provide the class with DisplayObjects for it to scroll.</p>	*	<p>The Class supports scrolling in response to mouse movement over the panel, or via a public method.</p>	*	<p>It also suppors creating rows or columns of content and scrolling that. The Class also supports scaling its mask to browsers dimensions	*	or you can simply set it to a fixed size. You are also able to remove individual content items and the class will update the position	*	of the content items to accomodate items being removed.</p>	*	<p>Each content item is wrapped in a NpScrollingPanelItem Instance, which dispatches various custom mouse events. You can use these events to	*	track what content item has been clicked etc. Useful for using this class as part of a gallery etc.</p>	* 	<br /><br />	*	<b>Author:</b> noponies - <a href="http://www.blog.noponies.com/" target="_blank">www.blog.noponies.com</a><br />	* 	<b>Class version:</b> 1.0<br />	* 	<b>Actionscript version:</b> 3.0 Player Version 9.0.28<br />	* 	<b>Copyright:</b>	*	2008 Noponies - Dale Sattler	* 	<b>Date:</b> 02 Jan 2009<br />	* 	<b>Terms of use:</b> <a href="http://www.blog.noponies.com/terms-and-conditions" target="_blank">http://www.blog.noponies.com/terms-and-conditions</a>	*/		public class NpScrollingPanel extends Sprite {		//--------------------------------------		// PRIVATE INSTANCE PROPERTIES		//--------------------------------------		private var _maskWidth:int;		private var _maskHeight:int;		private var _counter:int;		private var _padding:int = 10;		private var _thumbY_pos:int		private var _thumbX_pos:int		private var _thumbMask:Sprite;		private var _thumbsHolder:Sprite;		private var _thumbsHolderBg:Sprite;		private var _itemArray:Array		private var _hitRect:Rectangle		private var _drawBg:Boolean = true		private var _bgColour:uint = 0xFFFFFF		private var _bgAlpha:Number = 1		private var _blurScroll:Boolean = false		private var _blurQual:int = 3		//scroller variables		private var _useMouseScroll:Boolean = true;		private var _useEndScroll:Boolean = false					//End scroll		private var _endScrollMaxSpeed:int = 40						//End scroll		private var _endScrollMargin:Number = .125					//End scroll		private var _scrollSpeed:int = 20				private var _pos:Number = 0;		private var _panelDirection:String = "horizontal";		private var _useStageDim:Boolean = true;		private var _mPos:int;		private var _targPos:Number;		private var _scrollingEnabled:Boolean;		private var _mX:int;		private var _mY:int;		private var _cachePanelAsBit:Boolean = true;		private var _blurAmount:Number = .4;		private var _panelReflect:Boolean = false;		private var _clipHalf:Number;		private var _myTween:TweenLite;		private var _changeVal:Number = 0;		private var _oldVal:Number = 0;		//buttonmode for panel items		private var _contentBmode:Boolean = false;		//timer that handles blurring the panel items		private var _blurTimer:Timer = new Timer(30);		private var _oldPos:int = 0;				//--------------------------------------		// GETTERS / SETTERS		//--------------------------------------		/**		 *	Get / Set if the thumbnails have a reflection. The reflection is always at the bottom of your scrolling content. This means, that this works better for content scrolling		 * 	in the <code>x</code> direction.		 *	<p>If you are scrolling in the x direction, then you need to increase your panels mask height by 25% of the height of your content min. If you are scrolling in the y direction, then you must increase the _padding between		 *	each content item.</p>		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	<p><em>Enabling this and panel blurring with decrease performance.</em></p>		 *	@default false		 *	@see #panelMaskHeight		 *	@see #contentPadding		 *	@return Boolean		 */		public function get panelReflection():Boolean {			return _panelReflect;		}		/**		* @private		*/		public function set panelReflection(newBgReflect:Boolean):void {			_panelReflect = newBgReflect;		}				/**		 *	Get / Set the buttonMode for each content item currently being added to the Class.		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	@default false		 *	@return Boolean		 */		public function get contentButtonMode():Boolean {			return _contentBmode;		}		/**		* @private		*/		public function set contentButtonMode(newButtMode:Boolean):void {			_contentBmode = newButtMode;		}				/**		 *	Get / Set the colour of the scrolling panel.		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	@default 0xFFFFFF (White)		 *	@return uint		 *	@see panelBgAlpha		 */		public function get panelBgColour():uint {			return _bgColour;		}		/**		* @private		*/		public function set panelBgColour(newBgCol:uint):void {			_bgColour = newBgCol;		}				/**		 *	Get / Set the alpha of the colour of the scrolling panels background.		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	@default 1 (solid)		 *	@return Number		 *	@see panelBgColour		 */		public function get panelBgAlpha():Number {			return _bgAlpha;		}		/**		* @private		*/		public function set panelBgAlpha(newBgAlpha:Number):void {			_bgAlpha = newBgAlpha;		}				/**		 *	Get / Set the spacing between each content item within the NpScrollingPanel.		 *	<p><em>This is a Class Instantiation Property. But you can use the <code>adjustPadding()</code> method to change padding at runtime!</em></p>		 *	@default 10		 *	@return int		 */		public function get contentPadding():int {			return _padding;		}		/**		* @private		*/		public function set contentPadding(newThumbPadding:int):void {			_padding = newThumbPadding;		}		/**		 *	Get / Set the <code>y</code> _position of each thumbnail in within the NpScrollingPanel. The pur_pose of this property is to enable you to		 *	create mulit rows of content within the NpScrollingPanel. 		 *	<p>To create a extra row of thumbnails within the NpScrollingPanel you would set both the <code>contentY_position</code> and the <code>contentX_position</code> 		 *	properties. For instance, if you are wanting to scroll content horizontally, with two rows after say the 10th element, you would reset the <code>contentX_position</code> to <code>0</code>		 *	as this property increments with each new thumbnail addition as well as changing the <code>contentY_position</code> to reflect the new <code>y</code> value of the next row of content.</p>		 *	<p><em>This is a Class Instantiation Property</em></p>		 *	@default 0		 *	@return int		 */		public function get contentY_position():int {			return _thumbY_pos;		}		/**		* @private		*/		public function set contentY_position(newThumbY_pos:int):void {			_thumbY_pos = newThumbY_pos;		}				/**		 *	Get / Set the <code>x</code> _position of each thumbnail in within the NpScrollingPanel. The pur_pose of this property is to enable you to		 *	create mulit columns of content within the NpScrollingPanel. 		 *	<p>To create a extra row of thumbnails within the NpScrollingPanel you would set both the <code>contentX_position</code> and the <code>contentY_position</code> 		 *	properties. For instance, if you are wanting to scroll content vertically, with two rows after say the 10th element, you would reset the <code>contentY_position</code> to <code>0</code>		 *	as this property increments with each new thumbnail addition as well as changing the <code>contentX_position</code> to reflect the new <code>x</code> value of the next column of content.</p>		 *	<p><em>This is a Class Instantiation Property</em></p>		 *	@default 0		 *	@return int		 */		public function get contentX_position():int {			return _thumbX_pos;		}		/**		* @private		*/		public function set contentX_position(newThumbX_pos:int):void {			_thumbX_pos = newThumbX_pos;		}						/**		 *	Get / Set the visible width of the thumbs track. This value is sets the width of the mask that that thumbs scroll behind. Has no effect if		 *	the <code>resizeThumbMaskToStage</code> property is enabled and you are scrolling content in the <code>horizontal</code> direction.		 *	@default 0		 *	@return int		 *	@see #resizePanelMaskToStage		 */		public function get panelMaskWidth():int {			return _maskWidth;		}		/**		* @private		*/		public function set panelMaskWidth(newMaskWidth:int):void {			_maskWidth = newMaskWidth;		}				/**		 *	Get / Set the visible height of the thumbs track. This value is sets the height of the mask that that thumbs scroll behind. Has no effect if		 *	the <code>resizePanelMaskToStage</code> property is enabled and you are scrolling content in the <code>vertical</code> direction.		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return int		 *	@see #resizePanelMaskToStage		 */		public function get panelMaskHeight():int {			return _maskHeight;		}		/**		* @private		*/		public function set panelMaskHeight(newMaskHeight:int):void {			_maskHeight = newMaskHeight;		}				/**		 *	Get / Set the whether or not the thumb track stretches to match either the stages width, or stages height, depending on what orientation the NpScrollingPanel happens to be in.		 *	<p><em>Make sure you set the op_posite track dimension value to the NpScrollingPanels orientation. So, if you are creating a horizontal thumb track, make sure you set the <code>panelMaskHeight</code> property.</em></p>		 *	<p><em>You can set this property at runtime.</em></p>		 *	@default 0 or stage.stageWidth		 *	@return Boolean		 */		public function get resizePanelMaskToStage():Boolean {			return _useStageDim;		}		/**		* @private		*/		public function set resizePanelMaskToStage(newUseStageDim:Boolean):void {			_useStageDim = newUseStageDim;		}				/**		 *	Get / Set whether or not the thumb scrolling is controlled by a user moving their mouse over the NpScrollingPanel.		 *	<p><em>You can set this property at runtime.</em></p>		 *	@default true		 *	@return Boolean		 */		public function get mouseScrolling():Boolean {			return _useMouseScroll;		}		/**		* @private		*/		public function set mouseScrolling(newUseMouseScroll:Boolean):void {			_useMouseScroll = newUseMouseScroll;		}				/**		 *	Get / Set the max speed the panel can scroll at. This property gives you access to the duration that the internal tweens run for. Each		 *	tween is set to run with the <code>useFrames</code> property set to true. So, larger numbers passed in here, result in slower tweens and thus		 *	slower scrolling as the tweens take longer to complete.		  *	<p><em>You can set this property at runtime.</em></p>		 *	@default 20		 *	@return int		 */		public function get scrollSpeed():int {			return _scrollSpeed;		}		/**		* @private		*/		public function set scrollSpeed(newSpeed:int):void {			_scrollSpeed = newSpeed;		}				/**		 *	Get / Set whether or not the thumb scrolling is controlled by a user moving their mouse over extreme left and right of the panel.		 *	<p><b>Note: You must also set the <code>mouseScrolling</code> property to true for this property to have any effect!</b></p>		 *	<p>You should also set the distance the edge of the panel is "active" for. By default this zone is .125% of the width of the panels		 *	mask.</p>		 *	<p>This value is calculated as a percentage of the users mouse _position inside the active zone verses either the right or the left of the panel. So, if		 *	a user has their mouse 99% to the left the panel, then the panel will scroll at 99% of the max speed set for the <code>panelEdgeScrollSpeed</code>.</p>		 *	@default false		 *	@return Boolean		 *	@see  panelEdgeScrollSpeed		 *	@see  panelEdgeScrollSpeed		 		 *	@see  mouseScrolling		 */		public function get panelEdgeScrolling():Boolean {			return _useEndScroll;		}		/**		* @private		*/		public function set panelEdgeScrolling(newUseMouseScroll:Boolean):void {			_useEndScroll = newUseMouseScroll;		}				/**		 *	Get / Set the max speed the panel can scroll at when in <code>panelEdgeScrolling</code> mode. Remember that, this is the max speed the panel can scroll at. The actual		 *	speed is a percentage of the <code>panelEdgeScrollMargin</code> property.		 *	@default 40		 *	@return int		 *	@see  panelEdgeScrolling		 *	@see  panelEdgeScrollMargin		  		 */		public function get panelEdgeScrollSpeed():int {			return _endScrollMaxSpeed;		}		/**		* @private		*/		public function set panelEdgeScrollSpeed(newEndScrollMaxSpeed:int):void {			_endScrollMaxSpeed = newEndScrollMaxSpeed;		}				/**		 *	Get / Set the size of the "active" area of the scrolling panel when you have enabled the <code>panelEdgeScrolling</code> property. 		 *	<p>This value is calculated as a percentage of the panels width or height. So, if you have panel width of 100px and you set this property to .125, then the active		 *	area will be 125px at each edge of the panel.</p>		 *	@default .125		 *	@return Number		 *	@see  panelEdgeScrolling		 *	@see  panelEdgeScrollSpeed				 		 */		public function get panelEdgeScrollMargin():Number {			return _endScrollMargin;		}		/**		* @private		*/		public function set panelEdgeScrollMargin(newEndScrollMargin:Number):void {			_endScrollMargin = newEndScrollMargin;		}		/**		 *	Get / Set the _position of the thumbsTrack as a <code>percentage!</code> of the NpScrollingPanels mask (visible area) width. Valid value range is within the <code>0-1</code> range.		 *	<p>Use this property to scroll the thumbsTrack via external means, such as a slider bar or a mouse Click on a button</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return Number		 */		public function get panelScrollPos():Number {			return _panelDirection == "horizontal" ? - _thumbsHolder.x / (_thumbsHolder.width - _thumbMask.width) : - _thumbsHolder.y / (_thumbsHolder.height - _thumbMask.height)		}		/**		* @private		*/		public function set panelScrollPos(newTrackPos:Number):void {			if(!_scrollingEnabled){				return			}			//test _thumbsHolder bounds against thumbMask, thumbsHolder must be larger than mask			if((_panelDirection == "horizontal" && _thumbsHolder.width <= _thumbMask.width)||(_panelDirection == "vertical" && _thumbsHolder.height <= _thumbMask.height)){				return			}			_panelDirection == "horizontal" ? doTween(-newTrackPos) : doTween(-newTrackPos) 		}				/**		 *	Get / Set the _position of the thumbsTrack as an int rather than as a percentage. Use this property if you want to _position the scrolling panel at an exact int value.		 *	<p>Use this property to scroll the thumbsTrack via external means, such as a slider bar or a mouse Click on a button</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return int		 */		public function get panelScrollPosAsInt():int {			return _panelDirection == "horizontal" ? - _thumbsHolder.x : - _thumbsHolder.y 		}		/**		* @private		*/		public function set panelScrollPosAsInt(newTrackPos:int):void {			if(!_scrollingEnabled){				return			}			//test _thumbsHolder bounds against thumbMask, thumbsHolder must be larger than mask			if((_panelDirection=="horizontal" && _thumbsHolder.width<=_thumbMask.width)||(_panelDirection=="vertical" && _thumbsHolder.height<=_thumbMask.height)){				return			}			_panelDirection=="horizontal" ? doIntTween(-newTrackPos) : doIntTween(-newTrackPos) 		}				/**		 *	Get / Set if you want to blur the scrolled content as it scrolls. The amount of blur depends on how far the content has to scroll. Bigger distances		 * 	equate to bigger blurs. Content is blurred in the direction it is scrolling in.		 *	<p><strong>Blurring will swap to a slower process of iterating over each object in the scrolling panel if the content being scrolled exceeds either a height or width of 2880px.		 *	When you scroll content that is over this dimension, each individual item is blurred, rather than the panel as a whole. This is caused by a Flash limit of 2880px for bitmap objects.</strong></p>		 *	<p><em>Be aware that this will affect peformance</em></p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default false		 *	@return Boolean		 *	@see #panelBlurQuality		 */		public function get panelScrollBlur():Boolean {			return _blurScroll		}		/**		* @private		*/		public function set panelScrollBlur(newBlur:Boolean):void {			_blurScroll = newBlur		}				/**		 *	Get / Set the quality of the blur if you have enabled the <code>panelScrollBlur</code> property. Higher numbers set higher quality blurs but degrade performance!		 *	<p><em>Be aware that this high will affect peformance</em></p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 3		 *	@return int		 *	@see panelScrollBlur		 */		public function get panelBlurQuality():int {			return _blurQual		}		/**		* @private		*/		public function set panelBlurQuality(newBlurQual:int):void {			_blurQual = newBlurQual		}				/**		 *	Get / Set the amount of the blurring if you have enabled the <code>panelScrollBlur</code> property. Higher numbers create greater amounts of blur!		 *	<p>Blurring is a proportion of the distance the panel has to travel. The effect of this property is to divide that amount to arrive at the level of blur.		 *	So, if you set a amount of <code>.5</code> then the blur will be calculated as .5 of that distance.</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default .4		 *	@return Number		 *	@see panelScrollBlur		 */		public function get panelBlurAmount():Number {			return _blurAmount		}		/**		* @private		*/		public function set panelBlurAmount(newBlurAmount:Number):void {			_blurAmount = newBlurAmount		}				/**		 *	Get / Set whether or not to cache the scrolling content as a whole as a bitmap. This increases performance, but you will suffer a performance hit if your content		 *	visually changes etc. 		 *	<p>If you have enabled the <code>panelScrollBlur</code> property, the scrolling content will be bitmap cached when it is blurred, and returned to is previous cache state		 *	when the blur has finished.</p>		 *	<p><em>This property is tested each time the <code>enableScrolling</code> method is called.</em></p>		 *	@default true		 *	@return Boolean		 */		public function get renderPanelAsBitmap():Boolean {			return _cachePanelAsBit;		}		/**		* @private		*/		public function set renderPanelAsBitmap(newCachePanelAtBit:Boolean):void {			_cachePanelAsBit = newCachePanelAtBit;		}				/**		 *	Get width of the thumbs track. This is the width of the content that is scrolled.		 *	@default 0		 *	@return int		 */		public function get panelContentWidth():int {			return _thumbsHolder.width;		}				/**		 *	Get height of the thumbs track. This is the height of the content that is scrolled.		 *	@default 0		 *	@return int		 */		public function get panelContentHeight():int {			return _thumbsHolder.height;		}				//--------------------------------------		// CONSTRUCTOR		//--------------------------------------		/**		*	The NpScrollingPanel Class Constructor takes one argument. A string representing the direction you want to scroll your content within.		*	<p>To add content to this scrollingPanel use the <code>addContentItem()</code> method. When you have finished adding in your content that you wish		*	to scroll, call the <code>enableScrolling()</code> method.</p>		*	<p>Set the <code>mouseScrolling, scrollEase, resizeThumbMaskToStage, panelEdgeScrolling, panelReflection,panelMaskWidth, panelBgColour, panelMaskHeight, contentPadding etc</code> properties before you call the <code>addContentItem()</code> method!</p>		*	<p>Use the <code>contentX_position</code> and <code>contentY_position</code> properties as you add content to the NpScrollingPanel class </em>if</em> you want to create multiple rows and columns</p>		*	<p>If you need to access individual contentItems, you can access their various dispatched events, and from those events, hook into the event.target property. You can also simply  query the 		*	<code>accessThumb()</code> method.</p>		*	@param String (Optional) Representing the direction you want to scroll in. The default scrolling direction is <code>horizontal</code>!.		*	@see #mouseScrolling		*	@see #resizeThumbMaskToStage		*	@see #panelMaskHeight		*	@see #panelMaskWidth		*	@see #contentPadding			*	@see #renderPanelAsBitmap		*	@see #panelEdgeScrolling		*	@see #panelReflection		*	@see #panelBgColour		*	@see #panelScrollBlur		*	@see enableScrolling()		*	@see #noponies.events.NpScrollingPanelEvent		*	@return		*	<br>		*	@example Example Useage		*   <listing version="3.0">		*	//Create a new instance of NpScrollingPanel Class and populate it with bitmaps from the library. This will scroll in a horizontal or x direction!		*		*	var thumbsContainer:NpScrollingPanel = new NpScrollingPanel();		*	thumbsContainer.resizePanelMaskToStage = true		*	thumbsContainer.panelMaskHeight = 200		*	addChild(thumbsContainer);		*		*	var libraryItem:Bitmap;		*		*	function createNewPanel():void {		*		for (var i:int = 0; i< 15; i++) {		*			var n:int=i%2;		*			if (n==0) {		*				var FireybreathData:Fireybreath = new Fireybreath(0, 0);		*				libraryItem = new Bitmap(FireybreathData);		*			} else {		*				var StrawberryData:Strawberry = new Strawberry(0, 0);		*				libraryItem = new Bitmap(StrawberryData);		*			}		*			thumbsContainer.addContentItem(libraryItem)		*			//when we have finished adding content, turn on scrolling		*			if(i==15){		*			thumbsContainer.enableScrolling()		*		}		*		}			*	}		*		*	createNewPanel()		*		*	</listing>		*/		public function NpScrollingPanel(_panelDirection:String = "vertical") {			switch (_panelDirection.toLowerCase()) {				case "horizontal" :					this._panelDirection = _panelDirection.toLowerCase();					break;				case "vertical" :					this._panelDirection = _panelDirection.toLowerCase();					break;				default :				throw new Error("Problem :The direction parameter passed "+"\""+ _panelDirection+"\"" + " does not match the allowed orientation modes, which are: \"horizontal\", \"vertical\"");			};						init();		}		//--------------------------------------	//	// PUBLIC METHODS	//	//--------------------------------------	//--------------------------------------	// ADD CONTENT ITEM	//--------------------------------------		/**	*   The <code>addContentItem()</code> public method adds DisplayObjects to the NpScrollingPanel. 	*	@param DisplayObject Representing the DisplayObject you want to add to the NpScrollingPanel	*	@see #contentPadding	*	@see #contentX_position	*	@see #contentY_position	*	@return	*/	public function addContentItem(thumbContent:DisplayObject):void {		//new instance of the PanelItem Class, if you wanted to use your own class, you would add in here		var newThumb:NpScrollingPanelItem= new NpScrollingPanelItem(thumbContent, _counter, _panelDirection, _panelReflect);		_thumbsHolder.addChild(newThumb);		newThumb.buttonMode = _contentBmode		if (_panelDirection=="horizontal") {			newThumb.x = _thumbX_pos;			newThumb.y = _thumbY_pos;		} else {			newThumb.x = _thumbX_pos;			newThumb.y = _thumbY_pos;		}				//create the mask		if (_counter==0) {			if (_useStageDim&&_panelDirection=="horizontal") {				_maskWidth = stage.stageWidth;							}			if (_useStageDim&&_panelDirection=="vertical") {				_maskHeight = stage.stageHeight;			}						//create the mask sprite for the thumbs track			_thumbMask = new Sprite();			_thumbMask.graphics.beginFill(0xFFFFFF);			_thumbMask.graphics.drawRect(0, 0, _maskWidth, _maskHeight);			_thumbMask.graphics.endFill();			_thumbMask.x = 0;			_thumbMask.y = 0;			addChild(_thumbMask);			this.mask = _thumbMask;						//set the bg of the thumbs track which is needed to create a smooth scrolling experience to match			//the heights and widths of the first instance of the loaded in content			//this sprite is resized again, as the content loads			_thumbsHolderBg.height = thumbContent.height;			_thumbsHolderBg.width = thumbContent.width;		}				//increment the _positional _counter for the thumbs _positions		if (_panelDirection=="horizontal") {			if(_panelReflect) {				_thumbsHolderBg.width = _thumbsHolder.width;				_thumbsHolderBg.height = _maskHeight-newThumb.thumbHeight;			}else{				_thumbsHolderBg.width = _thumbsHolder.width;				_thumbsHolderBg.height = _maskHeight;			}			_thumbX_pos+=thumbContent.width+_padding;		} else {			_thumbsHolderBg.height = _thumbsHolder.height;			_thumbsHolderBg.width = _maskWidth;			_thumbY_pos+=thumbContent.height+_padding;		}		//create the _counter		_counter++;		_itemArray.push(newThumb)	}		//--------------------------------------	// ENABLE SCROLLING	//--------------------------------------		/**	*   The <code>enableScrolling()</code> public method will enable both mouse movement (Depending on if you have enabled the <code>mouseScrolling</code> or the <code>panelEdgeScrolling</code> property) 	*	and setter based scrolling.	*	@see #mouseScrolling	*	@see #panelEdgeScrolling	*	@see #panelScrollPos	*	@see disableScrolling()	*	@return	*/	public function enableScrolling():void {				//enable mouse based scrolling, if it desired. Note the slight inflation of the rectangle. We need to offset it slightly as Flash tests			//for less than when running a rectangle.contains() method. 			if(_panelReflect) {				_panelDirection=="horizontal" ? _hitRect = new Rectangle(0, 0, _maskWidth+1, _maskHeight) : _hitRect = new Rectangle(0, 0, _maskWidth, _maskHeight+1)			}else{				_panelDirection=="horizontal" ? _hitRect = new Rectangle(0, 0, _maskWidth+1, _maskHeight) : _hitRect = new Rectangle(0, 0, _maskWidth, _maskHeight+1)			}			if (_useMouseScroll) {				addScrollListeners();			}		_scrollingEnabled = true		//check to see if we are cacheing the content		_cachePanelAsBit ? _thumbsHolder.cacheAsBitmap = true : _thumbsHolder.cacheAsBitmap = false		 if(_blurScroll){			_blurTimer.addEventListener(TimerEvent.TIMER, handleBlur, false, 0, true)			_panelDirection == "horizontal" ?  _oldPos = _thumbsHolder.x : _oldPos = _thumbsHolder.y			_blurTimer.start()		 }		 		 //add the stage resize listener if its required		if(_useStageDim){			stage.addEventListener(Event.RESIZE, resizeHandler);		}		}	//--------------------------------------	// DISABLE SCROLLING	//--------------------------------------	/**	*   The <code>disableScrolling()</code> public method will disable both mouse movement based and setter based scrolling.	*	<p>To enable scrolling again, call the <code>enableScrolling</code> method.</p>	*	@see enableScrolling()		*	@return	*/	public function disableScrolling():void {		if (this.willTrigger(Event.ENTER_FRAME)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}		_scrollingEnabled = false		if(_blurScroll){			_blurTimer.stop()		 }		}		//--------------------------------------	// REMOVE A PARTICULAR THUMB	//--------------------------------------	/**	*   The <code>removeContentItem()</code> public method will remove a contentItem from the NpScrollingPanel. ContentItems with either a 	*	greater x or y (depending on scrolling direction) than the removed item will move their _positions to fill the 'gap' left my deleting	*	the contentItem.	*	<p>!! Removing content items when you have multi row or column scrollable content will _possibly cause errors</p>	*	<p>Pass in the ID of the thumbnail you want to delete. When thumbs are added to the thumbsTrack they are allocated an ID, which corresponds	*	to the order they are added in.</p>	*	@param int Representing the ID of the thumbnail you want to delete from the thumbsTrack.	*	@return	*/	public function removeContentItem(id:int):void {		var thumbToDeleteDim:Number		_panelDirection=="horizontal" ? thumbToDeleteDim = _itemArray[id].thumbWidth : thumbToDeleteDim = _itemArray[id].thumbHeight		_thumbsHolder.removeChild(_itemArray[id])		_itemArray.splice(id,1)					//iterate through elements contained in our _itemArray		var len:int = _itemArray.length		for (var i:int = 0; i< len; i++) {			_itemArray[i].removeClip(i, -thumbToDeleteDim-_padding)			}		if(_drawBg){			_panelDirection=="horizontal" ? _thumbsHolderBg.width -= thumbToDeleteDim+_padding : _thumbsHolderBg.height -= thumbToDeleteDim+_padding		}		//adjust _pos of panel if we are at the far right/bottom of the scroll and we remove a clip		if(_panelDirection=="horizontal"){			if(_thumbsHolder.x + _thumbsHolder.width <= _hitRect.width) _thumbsHolder.x += thumbToDeleteDim+_padding		}else{			if(_thumbsHolder.y + _thumbsHolder.height <= _hitRect.height) _thumbsHolder.y += thumbToDeleteDim+_padding		}	}		//--------------------------------------	// ADJUST THUMB PADDING	//--------------------------------------	/**	*   The <code>adjustPadding()</code> public method will adjust the _padding between each content item at runtime. Calling this method will	*	result in the content items tweening in unison to their new _positions.	*	@param int Representing the amount of _padding you would like between each thumbnail.	*	@see enableScrolling()		*	@return	*/	public function adjustPadding(newPadding:int):void {		var len:int = _itemArray.length		//iterate through elements contained in our itemArray		for (var i:int = 0; i< len; i++) {			_itemArray[i].adjustPadding(newPadding)			}		if(_drawBg){			_panelDirection=="horizontal" ? _thumbsHolderBg.width+= (newPadding*_itemArray.length)-newPadding : _thumbsHolderBg.height+= (newPadding*_itemArray.length)-newPadding; 		}	}		//--------------------------------------	// UNLOAD ALL THUMBS	//--------------------------------------		/**	*   The <code>removeAllContent()</code> public method will unload any thumbnails currently loaded. It will also reset the heights and widths	*	of the NpScrollingPanel. Any mouse event listeners registered with the NpScrollingPanel will also be removed.	*	<p>You would use this method if you wanted to repopulate the class with a new set of content.</p>	*	@return	*/	public function removeAllContent():void {		//kill scrolling		_scrollingEnabled = false		//kill any bluring		if(_blurScroll){			_blurTimer.stop()		 }				//deal with listeners first				if (this.willTrigger(Event.ENTER_FRAME)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}		if (_useMouseScroll) {				this.removeEventListener(MouseEvent.ROLL_OVER, mouseScroll);		}		//clear thumbs		if (_thumbsHolder.numChildren >1) {			while (_thumbsHolder.numChildren >1) {				_thumbsHolder.removeChildAt(1);			}		}		//reset internal props		_counter=0;		if(_drawBg){			_thumbsHolderBg.width = _thumbsHolderBg.height = 0;		}		_thumbY_pos = 0		_thumbX_pos = 0		this.mask = null;		removeChild(_thumbMask);		_itemArray = []		}	//--------------------------------------	// REFERENCE A PARTICULAR THUMB	//--------------------------------------				/**	*   The <code>accessThumb()</code> public method is a means of gaining access to a particular thumbNail within the thumbsTrack.	*	<p>You would use this method if you wanted to manipulate individual thumbNails.</p>	*	@return Object representing the thumbNail ID requested.	*/	public function accessThumb(id:int):Object{		return(_itemArray[id])	}			//--------------------------------------	//	// PRIVATE METHODS	//	//--------------------------------------		//--------------------------------------	// INIT HANDLER - CALLED FROM CONSTRUCTOR	//--------------------------------------	//create thumbs holder sprite here, just do this once		private function init():void {		_itemArray = []		_thumbsHolder = new Sprite();		addChild(_thumbsHolder);		addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);	}		//--------------------------------------	// ADDED TO STAGE HANDLER	//--------------------------------------		private function addedToStageHandler(event:Event):void {		removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		if(_drawBg){			_thumbsHolderBg = new Sprite();			_thumbsHolderBg.graphics.beginFill(_bgColour, _bgAlpha);			_thumbsHolderBg.graphics.drawRect(0, 0, 1, 1);			_thumbsHolderBg.graphics.endFill();			_thumbsHolder.addChildAt(_thumbsHolderBg,0);			_thumbsHolderBg.cacheAsBitmap = true		}		//add the stage resize listener if its required		if(_useStageDim){			stage.addEventListener(Event.RESIZE, resizeHandler);		}				addEventListener(Event.REMOVED_FROM_STAGE, handleRemovedFromStage)	}		//--------------------------------------	// RESIZE HANDLER	//--------------------------------------		private function resizeHandler(event:Event):void {		if (_useStageDim) {			if (_panelDirection=="horizontal") {				if (_thumbsHolder.x+_thumbsHolder.width<stage.stageWidth) {					_thumbsHolder.x = stage.stageWidth-_thumbsHolder.width;				}				//test for when the stage is resized when the thumbs are loading				if(_thumbsHolder.width<=stage.stageWidth){					_thumbsHolder.x = 0				}				_thumbMask.width = stage.stageWidth;				_thumbMask.height = _maskHeight				_hitRect = new Rectangle(1, 0, _thumbMask.width-1, _maskHeight)			} else {				if (_thumbsHolder.y+_thumbsHolder.height<stage.stageHeight) {					_thumbsHolder.y = stage.stageHeight-_thumbsHolder.height;				}				//test for when the stage is resized when the thumbs are loading				if(_thumbsHolder.height<=stage.stageHeight){					_thumbsHolder.x = 0				}				_thumbMask.height = stage.stageHeight;				_thumbMask.width = _maskWidth				_hitRect = new Rectangle(1, 0, _maskWidth, _thumbMask.height-1)			}		}	}	//--------------------------------------	//	// MOUSESCROLLING FUNCTIONS	//	//--------------------------------------	//function that simply adds the event listeners to our scroll track	//we call this when we have loaded in all the thumbs, as this stops a user from being	//able to scroll a half empty thumbnails track, which would look crap.		private function addScrollListeners():void {		addEventListener(MouseEvent.ROLL_OVER, mouseScroll);	}		//handlers that either add or delete the scroll enterframe event	private function mouseScroll(event:MouseEvent = null):void {		if(!_scrollingEnabled){				return			}		//test _thumbsHolder bounds against _thumbMask, _thumbsHolder must be larger than mask		if((_panelDirection=="horizontal" && _thumbsHolder.width<=_thumbMask.width)||(_panelDirection=="vertical" && _thumbsHolder.height<=_thumbMask.height)){				return			}					if(_blurScroll){			_panelDirection == "horizontal" ?  _oldPos = _thumbsHolder.x : _oldPos = _thumbsHolder.y			_blurTimer.start()		 }			//check to see if we have an enterframe event running, if not add it		if (! this.willTrigger(Event.ENTER_FRAME)) {			this.addEventListener(Event.ENTER_FRAME,entFrameScroll);		}	}		//--------------------------------------	// ENTERFRAME HANDLER	//--------------------------------------			private function entFrameScroll(event:Event):void{		//we have content to scroll, so lets scroll it!		_panelDirection=="horizontal" ? scrollThumbsX() : scrollThumbsY() 	}		//--------------------------------------	// TWEENING METHODS	//--------------------------------------	private function doTween(targetPos:Number):void{		var targetX:int = int((_thumbsHolder.width-_thumbMask.width)*targetPos);		var targetY:int = int((_thumbsHolder.height-_thumbMask.height)*targetPos);		_panelDirection == "horizontal" ?  _myTween = new TweenLite(_thumbsHolder, _scrollSpeed,			{x:targetX, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.x]});		:  _myTween = new TweenLite(_thumbsHolder,  _scrollSpeed,			{y:targetY, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.y]});			}		//tweens to a particular integer, or pixel _position rather than a percentage	private function doIntTween(targetPos:int):void{		_panelDirection == "horizontal" ?  _myTween = new TweenLite(_thumbsHolder, _scrollSpeed, 			{x:targetPos, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.x]});		:  _myTween = new TweenLite(_thumbsHolder,  _scrollSpeed, 			{y:targetPos, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.y]});	}		//--------------------------------------	// SCROLLING IN THE X DIRECTION	//--------------------------------------		private function scrollThumbsX():void {		//store the _position of the panel, with iteration of this method		//we use this to calculate how much distance we are moving		_oldVal = _thumbsHolder.x		if (_oldVal < 0)  _oldVal = -_oldVal;				//store mouse _pos as vars		_mX = mouseX;		_mY = mouseY;						if (!_hitRect.contains(_mX,_mY)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			return;		}		//EDGE SCROLLING		if(_useEndScroll){			if (mouseX < _hitRect.width * _endScrollMargin) 				_myTween = new TweenLite(_thumbsHolder, _scrollSpeed,					{x:_thumbsHolder.x + _endScrollMaxSpeed*(1-(_mX/int(_hitRect.width * _endScrollMargin))),						ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.x]}); 						if (mouseX > _hitRect.width*(1 - _endScrollMargin)) 				_myTween = new TweenLite(_thumbsHolder, _scrollSpeed,					{x:_thumbsHolder.x - _endScrollMaxSpeed*(int(_mX-(_hitRect.width-1) * (1 - _endScrollMargin))/int(_hitRect.width-_hitRect.width*(1 - _endScrollMargin))),						ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.x]});		}else{			//MOUSE MOVE SCROLLING			if (_mX < 0)  _mX = 0;			_mPos = _mX;			_targPos = -(_mPos/(_hitRect.width/(_thumbsHolder.width - _hitRect.width)))				_myTween = new TweenLite(_thumbsHolder, _scrollSpeed,				{x:_targPos, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.x]});		}		//dampening & kill event handler when we are belowing 1px movement increments		var n:int = quickAbs(_oldVal - _changeVal)		if (n < 1) {			if (!_useMouseScroll ||!_hitRect.contains(_mX,_mY)) {				this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			}		}	}		//--------------------------------------	// SCROLLING IN THE Y DIRECTION	//--------------------------------------			private function scrollThumbsY():void {		//store the _position of the panel, with iteration of this method		//we use this to calculate how much distance we are moving		_oldVal = _thumbsHolder.y		if (_oldVal < 0)  _oldVal = -_oldVal;				//store mouse _pos as vars		_mX = mouseX;		_mY = mouseY;				if (!_hitRect.contains(_mX,_mY)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			return;		}		//EDGE SCROLLING		if(_useEndScroll){			if (mouseY < _hitRect.height * _endScrollMargin)				_myTween = new TweenLite(_thumbsHolder, _scrollSpeed,					{y:_thumbsHolder.y + _endScrollMaxSpeed * (1-(_mY/int(_hitRect.height*_endScrollMargin))),						ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.y]});			if (mouseY > _hitRect.height*(1 - _endScrollMargin)) 				_myTween = new TweenLite(_thumbsHolder,  _scrollSpeed,					{y:_thumbsHolder.y - _endScrollMaxSpeed * (int(_mY-(_hitRect.height-1)*(1 - _endScrollMargin))/int(_hitRect.height-_hitRect.height*(1 - _endScrollMargin))),						ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.y]});		}else{			//MOUSE MOVE SCROLLING			if (_mY < 0)  _mY = 0;			_mPos = _mY;			_targPos = -(_mPos/(_hitRect.height/(_thumbsHolder.height - _hitRect.height)));				_myTween = new TweenLite(_thumbsHolder, _scrollSpeed,				{y:_targPos, ease:Strong.easeOut, onUpdate:checkBounds, onUpdateParams:[_thumbsHolder.y]}); 		}				//dampening & kill event handler when we are belowing 1px movement increments		var n:int = quickAbs(_oldVal - _changeVal)				if (n < 1) {			if (!_useMouseScroll ||!_hitRect.contains(_mX,_mY)) {				this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			}		}	}	//--------------------------------------	// PANEL BLURRING METHODS - USES A TIMER WHICH IS LESS OF A CPU HIT TO RUN	//--------------------------------------		//test the width / height of the panel content. If its over 2880 px, we have to move to a slower 'iterate over each thumb and blur that'	//type blur rather than a quicker blur on the _thumbsHolder sprite itself		private function handleBlur(event:TimerEvent):void {		var newPos:int 		var n:int		_oldPos = quickAbs(_oldPos)		_panelDirection=="horizontal" ? newPos = quickAbs(_thumbsHolder.x) : newPos = quickAbs(_thumbsHolder.y) 		//dampen the blur amount		n = Math.min(quickAbs( _oldPos - newPos), 10)				if(_panelDirection=="horizontal"){			doBlurX(n)			_oldPos = _thumbsHolder.x		}else{			doBlurY(n)			_oldPos = _thumbsHolder.y		}		if(n==0)killBlur()	}	private function doBlurX(n:Number):void {		if(_thumbsHolder.width<2880){			_thumbsHolder.filters=[new BlurFilter(0, (n* _blurAmount), _blurQual)]		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var p: Sprite = _itemArray[i]				p.filters=[new BlurFilter(0, (n * _blurAmount), _blurQual)]			}		}	}		private function doBlurY(n:Number):void {		if(_thumbsHolder.height<2880){			_thumbsHolder.filters=[new BlurFilter((n* _blurAmount),0 , _blurQual)]		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var p: Sprite = _itemArray[i]				_thumbsHolder.filters=[new BlurFilter((n* _blurAmount),0 , _blurQual)]			}		}	}		private function killBlur():void {		if(_thumbsHolder.width<2880 || _thumbsHolder.height<2880){			_thumbsHolder.filters=[]		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var s: Sprite = _itemArray[i]				s.filters=[]			}		}	}		//--------------------------------------	// CHECK SCROLL BOUNDS METHOD	//--------------------------------------			private function checkBounds(val:Number):void{		_changeVal = quickAbs(val);		if(_panelDirection == "horizontal") {			if(_thumbsHolder.x >= 0) {				_thumbsHolder.x = 0;			}						if(_thumbsHolder.x + _thumbsHolder.width <= _hitRect.width) {				_thumbsHolder.x = _hitRect.width - _thumbsHolder.width			}			//scrolling in the y direction			}else{				if(_thumbsHolder.y >= 0) {				_thumbsHolder.y = 0			}						if(_thumbsHolder.y + _thumbsHolder.height <= _hitRect.height) {				_thumbsHolder.y = _hitRect.height - _thumbsHolder.height			}		}		//dispatch the CONTENT_SLIDING event		dispatchEvent(new NpScrollingPanelEvent(NpScrollingPanelEvent.SCROLLING,true, false, undefined, panelScrollPos));	}			//--------------------------------------	// UTIITY METHODS	//--------------------------------------			private function quickAbs(val:Number):int{		if (val < 0)  val = -val;		return val;	}		//--------------------------------------	// HANDLE A REMOVED FROM STAGE EVENT	//--------------------------------------		//clean up the class when removed from stage	private function handleRemovedFromStage(event:Event):void {		try {			removeEventListener(Event.REMOVED_FROM_STAGE, handleRemovedFromStage)			if(_useStageDim){				stage.removeEventListener(Event.RESIZE, resizeHandler);			}					//call public removeAllContent Method			removeAllContent()						if(_blurScroll){					_blurTimer.stop()					_blurTimer.removeEventListener(TimerEvent.TIMER, handleBlur, false)			}			} catch (event:Error) {			trace("There was an error when attempting to delete all NpScrollingPanel content. This is the error: "+Error);		}	}}}